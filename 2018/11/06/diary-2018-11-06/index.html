<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="三点包子">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Promises/A+(译)"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="三点包子"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="三点包子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>三点包子</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Promises/A+(译)</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  主页
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  文档
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/wangxueliang">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:sandianbaozi@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By 三点包子</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2018-11-06</span>
            <span class="time">14:19:13</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/技术/">技术</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/promises/">#promises</a> <a class="tag" href="/tags/Promises-A/">#Promises/A+</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <blockquote>
<p><em>本文根据<a href="https://promisesaplus.com/" target="_blank" rel="noopener">官网文档</a>翻译，能力有限，有问题欢迎指正</em></p>
</blockquote>
<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title=" 概述 "></a><strong> 概述 </strong></h1><h6 id="emsp-emsp-Promises是一个可靠并可交互的JavaScript标准；被开发者制定，供所有开发者参考。"><a href="#emsp-emsp-Promises是一个可靠并可交互的JavaScript标准；被开发者制定，供所有开发者参考。" class="headerlink" title="&emsp;&emsp;Promises是一个可靠并可交互的JavaScript标准；被开发者制定，供所有开发者参考。"></a>&emsp;&emsp;Promises是一个可靠并可交互的JavaScript标准；被开发者制定，供所有开发者参考。</h6><h6 id="emsp-emsp-promsise表示异步操作的最终结果，通过then方法进行主要交互，该方法可注册两个回调方法（1、接受promise最终值-2、接受promise失败的错误原因）"><a href="#emsp-emsp-promsise表示异步操作的最终结果，通过then方法进行主要交互，该方法可注册两个回调方法（1、接受promise最终值-2、接受promise失败的错误原因）" class="headerlink" title="&emsp;&emsp;promsise表示异步操作的最终结果，通过then方法进行主要交互，该方法可注册两个回调方法（1、接受promise最终值 2、接受promise失败的错误原因）"></a>&emsp;&emsp;promsise表示异步操作的最终结果，通过then方法进行主要交互，该方法可注册两个回调方法（1、接受promise最终值 2、接受promise失败的错误原因）</h6><h6 id="emsp-emsp-此规范详细的规定了then方法的实现，为所有遵循Promises-A-规范的promises实现提供可靠的基础，因此可以认为该规范是非常稳定的，尽管Promises-A-组织偶尔可能会修改此规范，但是都是采用较小的向后兼容方式来解决一些极端情况，同时会经过仔细考虑、讨论和测试后，我们才会集成大型或向后不兼容的修改。"><a href="#emsp-emsp-此规范详细的规定了then方法的实现，为所有遵循Promises-A-规范的promises实现提供可靠的基础，因此可以认为该规范是非常稳定的，尽管Promises-A-组织偶尔可能会修改此规范，但是都是采用较小的向后兼容方式来解决一些极端情况，同时会经过仔细考虑、讨论和测试后，我们才会集成大型或向后不兼容的修改。" class="headerlink" title="&emsp;&emsp;此规范详细的规定了then方法的实现，为所有遵循Promises/A+规范的promises实现提供可靠的基础，因此可以认为该规范是非常稳定的，尽管Promises/A+组织偶尔可能会修改此规范，但是都是采用较小的向后兼容方式来解决一些极端情况，同时会经过仔细考虑、讨论和测试后，我们才会集成大型或向后不兼容的修改。"></a>&emsp;&emsp;此规范详细的规定了then方法的实现，为所有遵循Promises/A+规范的promises实现提供可靠的基础，因此可以认为该规范是非常稳定的，尽管Promises/A+组织偶尔可能会修改此规范，但是都是采用较小的向后兼容方式来解决一些极端情况，同时会经过仔细考虑、讨论和测试后，我们才会集成大型或向后不兼容的修改。</h6><h6 id="emsp-emsp-从历史来看，Promises-A-规范接受了早期的一些建议，同时扩展了一些好的规则，去掉了原规范的特殊情况和有问题的部分"><a href="#emsp-emsp-从历史来看，Promises-A-规范接受了早期的一些建议，同时扩展了一些好的规则，去掉了原规范的特殊情况和有问题的部分" class="headerlink" title="&emsp;&emsp;从历史来看，Promises/A+规范接受了早期的一些建议，同时扩展了一些好的规则，去掉了原规范的特殊情况和有问题的部分"></a>&emsp;&emsp;从历史来看，Promises/A+规范接受了早期的一些建议，同时扩展了一些好的规则，去掉了原规范的特殊情况和有问题的部分</h6><h6 id="emsp-emsp-最后，Promises-A-核心规范并没有涉及如何创建、解决或者拒绝promise，而是选择专注提供可通用的then方法，对于上述操作promise方法可能在其他规范中提及。"><a href="#emsp-emsp-最后，Promises-A-核心规范并没有涉及如何创建、解决或者拒绝promise，而是选择专注提供可通用的then方法，对于上述操作promise方法可能在其他规范中提及。" class="headerlink" title="&emsp;&emsp;最后，Promises/A+核心规范并没有涉及如何创建、解决或者拒绝promise，而是选择专注提供可通用的then方法，对于上述操作promise方法可能在其他规范中提及。"></a>&emsp;&emsp;最后，Promises/A+核心规范并没有涉及如何创建、解决或者拒绝promise，而是选择专注提供可通用的<font color="#1890ff">then</font>方法，对于上述操作promise方法可能在其他规范中提及。</h6><h2 id="1-术语"><a href="#1-术语" class="headerlink" title=" 1. 术语 "></a><strong> 1. 术语 </strong></h2><hr>
<h6 id="emsp-emsp-1-1-“promise”是一个具有then方法的对象或者函数，其行为遵循Promises-A-规范"><a href="#emsp-emsp-1-1-“promise”是一个具有then方法的对象或者函数，其行为遵循Promises-A-规范" class="headerlink" title="&emsp;&emsp;1.1. “promise”是一个具有then方法的对象或者函数，其行为遵循Promises/A+规范"></a>&emsp;&emsp;1.1. “promise”是一个具有then方法的对象或者函数，其行为遵循Promises/A+规范</h6><h6 id="emsp-emsp-1-2-“thenable”是一个定义then方法的对象或者函数"><a href="#emsp-emsp-1-2-“thenable”是一个定义then方法的对象或者函数" class="headerlink" title="&emsp;&emsp;1.2. “thenable”是一个定义then方法的对象或者函数"></a>&emsp;&emsp;1.2. “thenable”是一个定义then方法的对象或者函数</h6><h6 id="emsp-emsp-1-3-“value”是任意的JavaScript变量（包括undefined-thenable或promise对象）"><a href="#emsp-emsp-1-3-“value”是任意的JavaScript变量（包括undefined-thenable或promise对象）" class="headerlink" title="&emsp;&emsp;1.3. “value”是任意的JavaScript变量（包括undefined,thenable或promise对象）"></a>&emsp;&emsp;1.3. “value”是任意的JavaScript变量（包括undefined,thenable或promise对象）</h6><h6 id="emsp-emsp-1-4-“exception”是使用throw语句抛出的一个值"><a href="#emsp-emsp-1-4-“exception”是使用throw语句抛出的一个值" class="headerlink" title="&emsp;&emsp;1.4. “exception”是使用throw语句抛出的一个值"></a>&emsp;&emsp;1.4. “exception”是使用throw语句抛出的一个值</h6><h6 id="emsp-emsp-1-5-“reason”是一个promise被rejected的说明"><a href="#emsp-emsp-1-5-“reason”是一个promise被rejected的说明" class="headerlink" title="&emsp;&emsp;1.5. “reason”是一个promise被rejected的说明"></a>&emsp;&emsp;1.5. “reason”是一个promise被rejected的说明</h6><h2 id="2-要求"><a href="#2-要求" class="headerlink" title=" 2. 要求 "></a><strong> 2. 要求 </strong></h2><hr>
<h4 id="emsp-2-1-promise状态-必须是以下三种状态中的一种，等待状态（pending）、已完成（fulfilled）和-被拒绝（rejected）"><a href="#emsp-2-1-promise状态-必须是以下三种状态中的一种，等待状态（pending）、已完成（fulfilled）和-被拒绝（rejected）" class="headerlink" title="&emsp;2.1. promise状态-必须是以下三种状态中的一种，等待状态（pending）、已完成（fulfilled）和 被拒绝（rejected）"></a>&emsp;2.1. promise状态-必须是以下三种状态中的一种，等待状态（pending）、已完成（fulfilled）和 被拒绝（rejected）</h4><h6 id="emsp-emsp-2-1-1-当promise处于pending时："><a href="#emsp-emsp-2-1-1-当promise处于pending时：" class="headerlink" title="&emsp;&emsp;2.1.1. 当promise处于pending时："></a>&emsp;&emsp;2.1.1. 当promise处于pending时：</h6><h6 id="emsp-emsp-emsp-2-1-1-1-只能改变成fulfilled或者rejected"><a href="#emsp-emsp-emsp-2-1-1-1-只能改变成fulfilled或者rejected" class="headerlink" title="&emsp;&emsp;&emsp;2.1.1.1. 只能改变成fulfilled或者rejected"></a>&emsp;&emsp;&emsp;2.1.1.1. 只能改变成fulfilled或者rejected</h6><h6 id="emsp-emsp-2-1-2-当promise处于fulfilled时："><a href="#emsp-emsp-2-1-2-当promise处于fulfilled时：" class="headerlink" title="&emsp;&emsp;2.1.2. 当promise处于fulfilled时："></a>&emsp;&emsp;2.1.2. 当promise处于fulfilled时：</h6><h6 id="emsp-emsp-emsp-2-1-2-1-不能改变成其他任何状态"><a href="#emsp-emsp-emsp-2-1-2-1-不能改变成其他任何状态" class="headerlink" title="&emsp;&emsp;&emsp;2.1.2.1. 不能改变成其他任何状态"></a>&emsp;&emsp;&emsp;2.1.2.1. 不能改变成其他任何状态</h6><h6 id="emsp-emsp-emsp-2-1-2-2-必须有一个值，并且不能改变"><a href="#emsp-emsp-emsp-2-1-2-2-必须有一个值，并且不能改变" class="headerlink" title="&emsp;&emsp;&emsp;2.1.2.2. 必须有一个值，并且不能改变"></a>&emsp;&emsp;&emsp;2.1.2.2. 必须有一个值，并且不能改变</h6><h6 id="emsp-emsp-2-1-3-当promise处于rejected时："><a href="#emsp-emsp-2-1-3-当promise处于rejected时：" class="headerlink" title="&emsp;&emsp;2.1.3. 当promise处于rejected时："></a>&emsp;&emsp;2.1.3. 当promise处于rejected时：</h6><h6 id="emsp-emsp-emsp-2-1-3-1-不能改变成其他任何状态"><a href="#emsp-emsp-emsp-2-1-3-1-不能改变成其他任何状态" class="headerlink" title="&emsp;&emsp;&emsp;2.1.3.1. 不能改变成其他任何状态"></a>&emsp;&emsp;&emsp;2.1.3.1. 不能改变成其他任何状态</h6><h6 id="emsp-emsp-emsp-2-1-3-2-必须有一个被拒绝原因，并且不能改变"><a href="#emsp-emsp-emsp-2-1-3-2-必须有一个被拒绝原因，并且不能改变" class="headerlink" title="&emsp;&emsp;&emsp;2.1.3.2. 必须有一个被拒绝原因，并且不能改变"></a>&emsp;&emsp;&emsp;2.1.3.2. 必须有一个被拒绝原因，并且不能改变</h6><h6 id="emsp-这里，‘不可变’意味着恒等（即-），当时不意味着深层次恒等（比如说复杂类型，其属性可以改变）"><a href="#emsp-这里，‘不可变’意味着恒等（即-），当时不意味着深层次恒等（比如说复杂类型，其属性可以改变）" class="headerlink" title="&emsp;这里，‘不可变’意味着恒等（即===），当时不意味着深层次恒等（比如说复杂类型，其属性可以改变）"></a>&emsp;这里，‘不可变’意味着恒等（即===），当时不意味着深层次恒等（比如说复杂类型，其属性可以改变）</h6><h4 id="emsp-2-2-then方法-一个promise必须提供then方法，以便能访问当前状态、终值或被拒原因，then方法接受两个参数"><a href="#emsp-2-2-then方法-一个promise必须提供then方法，以便能访问当前状态、终值或被拒原因，then方法接受两个参数" class="headerlink" title="&emsp;2.2. then方法-一个promise必须提供then方法，以便能访问当前状态、终值或被拒原因，then方法接受两个参数;"></a>&emsp;2.2. then方法-一个promise必须提供then方法，以便能访问当前状态、终值或被拒原因，then方法接受两个参数;</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<h6 id="emsp-emsp-2-2-1-onFulfilled和onRejected两个参数都是可选："><a href="#emsp-emsp-2-2-1-onFulfilled和onRejected两个参数都是可选：" class="headerlink" title="&emsp;&emsp;2.2.1. onFulfilled和onRejected两个参数都是可选："></a>&emsp;&emsp;2.2.1. onFulfilled和onRejected两个参数都是可选：</h6><h6 id="emsp-emsp-emsp-2-2-1-1-如果onFulfilled不是一个方法，必须被忽略。"><a href="#emsp-emsp-emsp-2-2-1-1-如果onFulfilled不是一个方法，必须被忽略。" class="headerlink" title="&emsp;&emsp;&emsp;2.2.1.1. 如果onFulfilled不是一个方法，必须被忽略。"></a>&emsp;&emsp;&emsp;2.2.1.1. 如果onFulfilled不是一个方法，必须被忽略。</h6><h6 id="emsp-emsp-emsp-2-2-1-2-如果onRejected不是一个方法，必须被忽略。"><a href="#emsp-emsp-emsp-2-2-1-2-如果onRejected不是一个方法，必须被忽略。" class="headerlink" title="&emsp;&emsp;&emsp;2.2.1.2. 如果onRejected不是一个方法，必须被忽略。"></a>&emsp;&emsp;&emsp;2.2.1.2. 如果onRejected不是一个方法，必须被忽略。</h6><h6 id="emsp-emsp-2-2-2-如果onFulfilled是一个方法："><a href="#emsp-emsp-2-2-2-如果onFulfilled是一个方法：" class="headerlink" title="&emsp;&emsp;2.2.2. 如果onFulfilled是一个方法："></a>&emsp;&emsp;2.2.2. 如果onFulfilled是一个方法：</h6><h6 id="emsp-emsp-emsp-2-2-2-1-如果promise状态为fulfilled，这个方法必须被执行，并且第一个参数必须是promise的终值"><a href="#emsp-emsp-emsp-2-2-2-1-如果promise状态为fulfilled，这个方法必须被执行，并且第一个参数必须是promise的终值" class="headerlink" title="&emsp;&emsp;&emsp;2.2.2.1. 如果promise状态为fulfilled，这个方法必须被执行，并且第一个参数必须是promise的终值"></a>&emsp;&emsp;&emsp;2.2.2.1. 如果promise状态为fulfilled，这个方法必须被执行，并且第一个参数必须是promise的终值</h6><h6 id="emsp-emsp-emsp-2-2-2-2-如果promise没有fulfilled之前，不能被调用"><a href="#emsp-emsp-emsp-2-2-2-2-如果promise没有fulfilled之前，不能被调用" class="headerlink" title="&emsp;&emsp;&emsp;2.2.2.2. 如果promise没有fulfilled之前，不能被调用"></a>&emsp;&emsp;&emsp;2.2.2.2. 如果promise没有fulfilled之前，不能被调用</h6><h6 id="emsp-emsp-emsp-2-2-2-3-这个方法只能被调用一次"><a href="#emsp-emsp-emsp-2-2-2-3-这个方法只能被调用一次" class="headerlink" title="&emsp;&emsp;&emsp;2.2.2.3. 这个方法只能被调用一次"></a>&emsp;&emsp;&emsp;2.2.2.3. 这个方法只能被调用一次</h6><h6 id="emsp-emsp-2-2-3-如果onFulfilled是一个方法："><a href="#emsp-emsp-2-2-3-如果onFulfilled是一个方法：" class="headerlink" title="&emsp;&emsp;2.2.3. 如果onFulfilled是一个方法："></a>&emsp;&emsp;2.2.3. 如果onFulfilled是一个方法：</h6><h6 id="emsp-emsp-emsp-2-2-3-1-如果promise状态为rejected，这个方法必须被执行，并且第一个参数必须是promise的被拒绝的原因"><a href="#emsp-emsp-emsp-2-2-3-1-如果promise状态为rejected，这个方法必须被执行，并且第一个参数必须是promise的被拒绝的原因" class="headerlink" title="&emsp;&emsp;&emsp;2.2.3.1. 如果promise状态为rejected，这个方法必须被执行，并且第一个参数必须是promise的被拒绝的原因"></a>&emsp;&emsp;&emsp;2.2.3.1. 如果promise状态为rejected，这个方法必须被执行，并且第一个参数必须是promise的被拒绝的原因</h6><h6 id="emsp-emsp-emsp-2-2-3-2-如果promise没有rejected之前，不能被调用"><a href="#emsp-emsp-emsp-2-2-3-2-如果promise没有rejected之前，不能被调用" class="headerlink" title="&emsp;&emsp;&emsp;2.2.3.2. 如果promise没有rejected之前，不能被调用"></a>&emsp;&emsp;&emsp;2.2.3.2. 如果promise没有rejected之前，不能被调用</h6><h6 id="emsp-emsp-emsp-2-2-3-3-这个方法只能被调用一次"><a href="#emsp-emsp-emsp-2-2-3-3-这个方法只能被调用一次" class="headerlink" title="&emsp;&emsp;&emsp;2.2.3.3. 这个方法只能被调用一次"></a>&emsp;&emsp;&emsp;2.2.3.3. 这个方法只能被调用一次</h6><h6 id="emsp-emsp-2-2-4-onFulfilled和onRejected必须在执行环境堆栈仅包含平台代码时才可被调用-3-1"><a href="#emsp-emsp-2-2-4-onFulfilled和onRejected必须在执行环境堆栈仅包含平台代码时才可被调用-3-1" class="headerlink" title="&emsp;&emsp;2.2.4. onFulfilled和onRejected必须在执行环境堆栈仅包含平台代码时才可被调用[3.1]"></a>&emsp;&emsp;2.2.4. onFulfilled和onRejected必须在<a href="http://es5.github.io/#x10.3" target="_blank" rel="noopener">执行环境</a>堆栈仅包含平台代码时才可被调用[<a href="#3.1">3.1</a>]</h6><h6 id="emsp-emsp-2-2-5-onFulfilled和onRejected必须作为函数被调用-3-2"><a href="#emsp-emsp-2-2-5-onFulfilled和onRejected必须作为函数被调用-3-2" class="headerlink" title="&emsp;&emsp;2.2.5. onFulfilled和onRejected必须作为函数被调用[3.2]"></a>&emsp;&emsp;2.2.5. onFulfilled和onRejected必须作为函数被调用[<a href="#3.2">3.2</a>]</h6><h6 id="emsp-emsp-2-2-6-then方法可以在一个promise上执行多次："><a href="#emsp-emsp-2-2-6-then方法可以在一个promise上执行多次：" class="headerlink" title="&emsp;&emsp;2.2.6. then方法可以在一个promise上执行多次："></a>&emsp;&emsp;2.2.6. then方法可以在一个promise上执行多次：</h6><h6 id="emsp-emsp-emsp-2-2-6-1-如果promise是fulfilled时候，所有onFulfilled将按照传入then方法的顺序依次执行"><a href="#emsp-emsp-emsp-2-2-6-1-如果promise是fulfilled时候，所有onFulfilled将按照传入then方法的顺序依次执行" class="headerlink" title="&emsp;&emsp;&emsp;2.2.6.1. 如果promise是fulfilled时候，所有onFulfilled将按照传入then方法的顺序依次执行"></a>&emsp;&emsp;&emsp;2.2.6.1. 如果promise是fulfilled时候，所有onFulfilled将按照传入then方法的顺序依次执行</h6><h6 id="emsp-emsp-emsp-2-2-6-2-如果promise是rejected时候，所有onRejected将按照传入then方法的顺序依次执行"><a href="#emsp-emsp-emsp-2-2-6-2-如果promise是rejected时候，所有onRejected将按照传入then方法的顺序依次执行" class="headerlink" title="&emsp;&emsp;&emsp;2.2.6.2. 如果promise是rejected时候，所有onRejected将按照传入then方法的顺序依次执行"></a>&emsp;&emsp;&emsp;2.2.6.2. 如果promise是rejected时候，所有onRejected将按照传入then方法的顺序依次执行</h6><h6 id="emsp-emsp-2-2-7-then方法必须返回一个promise-3-3-："><a href="#emsp-emsp-2-2-7-then方法必须返回一个promise-3-3-：" class="headerlink" title="&emsp;&emsp;2.2.7. then方法必须返回一个promise[3.3]："></a>&emsp;&emsp;2.2.7. then方法必须返回一个promise[<a href="#3.3">3.3</a>]：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>
<h6 id="emsp-emsp-emsp-2-2-7-1-如果onFulfilled或onRejected返回一个x-则运行下面的-promise解决过程。"><a href="#emsp-emsp-emsp-2-2-7-1-如果onFulfilled或onRejected返回一个x-则运行下面的-promise解决过程。" class="headerlink" title="&emsp;&emsp;&emsp;2.2.7.1. 如果onFulfilled或onRejected返回一个x, 则运行下面的 promise解决过程。"></a>&emsp;&emsp;&emsp;2.2.7.1. 如果onFulfilled或onRejected返回一个x, 则运行下面的 promise解决过程。</h6><h6 id="emsp-emsp-emsp-2-2-7-2-如果onFulfilled或onRejected抛出一个异常e-promise2必须执行rejected，并带着错误原因e。"><a href="#emsp-emsp-emsp-2-2-7-2-如果onFulfilled或onRejected抛出一个异常e-promise2必须执行rejected，并带着错误原因e。" class="headerlink" title="&emsp;&emsp;&emsp;2.2.7.2. 如果onFulfilled或onRejected抛出一个异常e, promise2必须执行rejected，并带着错误原因e。"></a>&emsp;&emsp;&emsp;2.2.7.2. 如果onFulfilled或onRejected抛出一个异常e, promise2必须执行rejected，并带着错误原因e。</h6><h6 id="emsp-emsp-emsp-2-2-7-3-如果onFulfilled不是一个方法以及promise1状态是fulfilled-那么promise2状态也必须是fulfilled，并且返回和promise1一样的值"><a href="#emsp-emsp-emsp-2-2-7-3-如果onFulfilled不是一个方法以及promise1状态是fulfilled-那么promise2状态也必须是fulfilled，并且返回和promise1一样的值" class="headerlink" title="&emsp;&emsp;&emsp;2.2.7.3. 如果onFulfilled不是一个方法以及promise1状态是fulfilled, 那么promise2状态也必须是fulfilled，并且返回和promise1一样的值"></a>&emsp;&emsp;&emsp;2.2.7.3. 如果onFulfilled不是一个方法以及promise1状态是fulfilled, 那么promise2状态也必须是fulfilled，并且返回和promise1一样的值</h6><h6 id="emsp-emsp-emsp-2-2-7-4-如果onRejected不是一个方法以及promise1状态是rejected-那么promise2状态也必须是rejected，并且返回和promise1一样的拒绝原因"><a href="#emsp-emsp-emsp-2-2-7-4-如果onRejected不是一个方法以及promise1状态是rejected-那么promise2状态也必须是rejected，并且返回和promise1一样的拒绝原因" class="headerlink" title="&emsp;&emsp;&emsp;2.2.7.4. 如果onRejected不是一个方法以及promise1状态是rejected, 那么promise2状态也必须是rejected，并且返回和promise1一样的拒绝原因"></a>&emsp;&emsp;&emsp;2.2.7.4. 如果onRejected不是一个方法以及promise1状态是rejected, 那么promise2状态也必须是rejected，并且返回和promise1一样的拒绝原因</h6><h4 id="emsp-2-3-promise解决过程"><a href="#emsp-2-3-promise解决过程" class="headerlink" title="&emsp;2.3. promise解决过程"></a>&emsp;2.3. promise解决过程</h4><h6 id="emsp-emsp-promise解决过程是抽象的，它promoise和value做为输入，我们称之为-Resolve-promise-x-，如果x具有then方法以及看上去像一个promise，就可以尝试使promise接受x的状态，否则用x的值来执行promise。"><a href="#emsp-emsp-promise解决过程是抽象的，它promoise和value做为输入，我们称之为-Resolve-promise-x-，如果x具有then方法以及看上去像一个promise，就可以尝试使promise接受x的状态，否则用x的值来执行promise。" class="headerlink" title="&emsp;&emsp; promise解决过程是抽象的，它promoise和value做为输入，我们称之为[[Resolve]](promise, x)，如果x具有then方法以及看上去像一个promise，就可以尝试使promise接受x的状态，否则用x的值来执行promise。"></a>&emsp;&emsp; promise解决过程是抽象的，它promoise和value做为输入，我们称之为<font style="color:#1890ff;background-color: #e2dcdc;padding:3px">[[Resolve]](promise, x)</font>，如果x具有then方法以及看上去像一个promise，就可以尝试使promise接受x的状态，否则用x的值来执行promise。</h6><h6 id="emsp-emsp-这种-thenable-的特性使得-Promise-的实现更具有通用性：只要其暴露出一个遵循-Promise-A-协议的-then-方法即可；这同时也使遵循-Promise-A-规范的实现可以与那些不太规范但可用的实现能良好共存。"><a href="#emsp-emsp-这种-thenable-的特性使得-Promise-的实现更具有通用性：只要其暴露出一个遵循-Promise-A-协议的-then-方法即可；这同时也使遵循-Promise-A-规范的实现可以与那些不太规范但可用的实现能良好共存。" class="headerlink" title="&emsp;&emsp;  这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。"></a>&emsp;&emsp;  这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 then 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</h6><h6 id="emsp-emsp-去执行-Resolve-promise-x-，需要遵循以下步骤："><a href="#emsp-emsp-去执行-Resolve-promise-x-，需要遵循以下步骤：" class="headerlink" title="&emsp;&emsp; 去执行[[Resolve]](promise, x)，需要遵循以下步骤："></a>&emsp;&emsp; 去执行<font style="color:#1890ff;background-color: #e2dcdc;padding:3px">[[Resolve]](promise, x)</font>，需要遵循以下步骤：</h6><h6 id="emsp-emsp-2-3-1-如果promise和x指向同一个对象，将rejected同时抛出一个typeError做为原因"><a href="#emsp-emsp-2-3-1-如果promise和x指向同一个对象，将rejected同时抛出一个typeError做为原因" class="headerlink" title="&emsp;&emsp;2.3.1. 如果promise和x指向同一个对象，将rejected同时抛出一个typeError做为原因"></a>&emsp;&emsp;2.3.1. 如果promise和x指向同一个对象，将rejected同时抛出一个typeError做为原因</h6><h6 id="emsp-emsp-2-3-2-如果x是一个promise-将使promise接受x的状态-3-4"><a href="#emsp-emsp-2-3-2-如果x是一个promise-将使promise接受x的状态-3-4" class="headerlink" title="&emsp;&emsp;2.3.2. 如果x是一个promise,将使promise接受x的状态[3.4]"></a>&emsp;&emsp;2.3.2. 如果x是一个promise,将使promise接受x的状态[<a href="#3.4">3.4</a>]</h6><h6 id="emsp-emsp-emsp-2-3-2-1-如果x状态为pending，就让promise状态也是pending，直到x变为fulfilled或者rejected"><a href="#emsp-emsp-emsp-2-3-2-1-如果x状态为pending，就让promise状态也是pending，直到x变为fulfilled或者rejected" class="headerlink" title="&emsp;&emsp;&emsp;2.3.2.1. 如果x状态为pending，就让promise状态也是pending，直到x变为fulfilled或者rejected"></a>&emsp;&emsp;&emsp;2.3.2.1. 如果x状态为pending，就让promise状态也是pending，直到x变为fulfilled或者rejected</h6><h6 id="emsp-emsp-emsp-2-3-2-2-如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变"><a href="#emsp-emsp-emsp-2-3-2-2-如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变" class="headerlink" title="&emsp;&emsp;&emsp;2.3.2.2. 如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变"></a>&emsp;&emsp;&emsp;2.3.2.2. 如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变</h6><h6 id="emsp-emsp-emsp-2-3-2-3-如果x状态为rejected，则用相同的拒绝原因去触发promise的rejected改变"><a href="#emsp-emsp-emsp-2-3-2-3-如果x状态为rejected，则用相同的拒绝原因去触发promise的rejected改变" class="headerlink" title="&emsp;&emsp;&emsp;2.3.2.3. 如果x状态为rejected，则用相同的拒绝原因去触发promise的rejected改变"></a>&emsp;&emsp;&emsp;2.3.2.3. 如果x状态为rejected，则用相同的拒绝原因去触发promise的rejected改变</h6><h6 id="emsp-emsp-2-3-3-如果x是一个对象或者函数"><a href="#emsp-emsp-2-3-3-如果x是一个对象或者函数" class="headerlink" title="&emsp;&emsp;2.3.3. 如果x是一个对象或者函数"></a>&emsp;&emsp;2.3.3. 如果x是一个对象或者函数</h6><h6 id="emsp-emsp-emsp-2-3-3-1-把-x-then-赋值给-then-3-5"><a href="#emsp-emsp-emsp-2-3-3-1-把-x-then-赋值给-then-3-5" class="headerlink" title="&emsp;&emsp;&emsp;2.3.3.1. 把 x.then 赋值给 then[3.5]"></a>&emsp;&emsp;&emsp;2.3.3.1. 把 x.then 赋值给 then[<a href="#3.5">3.5</a>]</h6><h6 id="emsp-emsp-emsp-2-3-3-2-如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变"><a href="#emsp-emsp-emsp-2-3-3-2-如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变" class="headerlink" title="&emsp;&emsp;&emsp;2.3.3.2. 如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变"></a>&emsp;&emsp;&emsp;2.3.3.2. 如果x状态为fulfilled，则用相同的值去触发promise的fulfilled改变</h6><h6 id="emsp-emsp-emsp-2-3-3-3-如果-then-是函数，将x作为函数的作用域this调用。接受两个参数，第一个参数叫做-resolvePromise-，第二个参数叫做-rejectPromise"><a href="#emsp-emsp-emsp-2-3-3-3-如果-then-是函数，将x作为函数的作用域this调用。接受两个参数，第一个参数叫做-resolvePromise-，第二个参数叫做-rejectPromise" class="headerlink" title="&emsp;&emsp;&emsp;2.3.3.3. 如果 then 是函数，将x作为函数的作用域this调用。接受两个参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise"></a>&emsp;&emsp;&emsp;2.3.3.3. 如果 then 是函数，将x作为函数的作用域this调用。接受两个参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</h6><h6 id="emsp-emsp-emsp-emsp-2-3-3-3-1-如果resolvePromise已值y为参数被调用，则运行-Resolve-promise-y"><a href="#emsp-emsp-emsp-emsp-2-3-3-3-1-如果resolvePromise已值y为参数被调用，则运行-Resolve-promise-y" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;2.3.3.3.1. 如果resolvePromise已值y为参数被调用，则运行[[Resolve]](promise, y)"></a>&emsp;&emsp;&emsp;&emsp;2.3.3.3.1. 如果resolvePromise已值y为参数被调用，则运行<font style="color:#1890ff;background-color: #e2dcdc;padding:3px">[[Resolve]](promise, y)</font></h6><h6 id="emsp-emsp-emsp-emsp-2-3-3-3-2-如果rejectPromise已拒绝原因r为参数被调用，则以r为原因拒绝promise"><a href="#emsp-emsp-emsp-emsp-2-3-3-3-2-如果rejectPromise已拒绝原因r为参数被调用，则以r为原因拒绝promise" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;2.3.3.3.2. 如果rejectPromise已拒绝原因r为参数被调用，则以r为原因拒绝promise"></a>&emsp;&emsp;&emsp;&emsp;2.3.3.3.2. 如果rejectPromise已拒绝原因r为参数被调用，则以r为原因拒绝promise</h6><h6 id="emsp-emsp-emsp-emsp-2-3-3-3-3-如果resolvePromise和rejectPromise均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用"><a href="#emsp-emsp-emsp-emsp-2-3-3-3-3-如果resolvePromise和rejectPromise均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;2.3.3.3.3. 如果resolvePromise和rejectPromise均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用"></a>&emsp;&emsp;&emsp;&emsp;2.3.3.3.3. 如果resolvePromise和rejectPromise均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</h6><h6 id="emsp-emsp-emsp-emsp-2-3-3-3-4-如果调用-then-方法抛出了异常-e"><a href="#emsp-emsp-emsp-emsp-2-3-3-3-4-如果调用-then-方法抛出了异常-e" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;2.3.3.3.4. 如果调用 then 方法抛出了异常 e"></a>&emsp;&emsp;&emsp;&emsp;2.3.3.3.4. 如果调用 then 方法抛出了异常 e</h6><h6 id="emsp-emsp-emsp-emsp-emsp-2-3-3-3-4-1-如果-resolvePromise-或-rejectPromise-已经被调用，则忽略之"><a href="#emsp-emsp-emsp-emsp-emsp-2-3-3-3-4-1-如果-resolvePromise-或-rejectPromise-已经被调用，则忽略之" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;&emsp;2.3.3.3.4.1. 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之"></a>&emsp;&emsp;&emsp;&emsp;&emsp;2.3.3.3.4.1. 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</h6><h6 id="emsp-emsp-emsp-emsp-emsp-2-3-3-3-4-2-否则以-e-为拒绝原因拒绝-promise"><a href="#emsp-emsp-emsp-emsp-emsp-2-3-3-3-4-2-否则以-e-为拒绝原因拒绝-promise" class="headerlink" title="&emsp;&emsp;&emsp;&emsp;&emsp;2.3.3.3.4.2. 否则以 e 为拒绝原因拒绝 promise"></a>&emsp;&emsp;&emsp;&emsp;&emsp;2.3.3.3.4.2. 否则以 e 为拒绝原因拒绝 promise</h6><h6 id="emsp-emsp-2-3-4-如果-x-不为对象或者函数，以-x-为参数执行-promise"><a href="#emsp-emsp-2-3-4-如果-x-不为对象或者函数，以-x-为参数执行-promise" class="headerlink" title="&emsp;&emsp;2.3.4. 如果 x 不为对象或者函数，以 x 为参数执行 promise"></a>&emsp;&emsp;2.3.4. 如果 x 不为对象或者函数，以 x 为参数执行 promise</h6><h5 id="emsp-如果一个-promise-被一个循环的-thenable-链中的对象解决，而-Resolve-promise-y-的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励开发者检测这样的递归是否存在，若检测到存在则以一个可识别的-TypeError-为拒绝原因来拒绝-promise-3-6"><a href="#emsp-如果一个-promise-被一个循环的-thenable-链中的对象解决，而-Resolve-promise-y-的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励开发者检测这样的递归是否存在，若检测到存在则以一个可识别的-TypeError-为拒绝原因来拒绝-promise-3-6" class="headerlink" title="&emsp; 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 [[Resolve]](promise, y) 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励开发者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为拒绝原因来拒绝 promise [3.6]"></a>&emsp; 如果一个 promise 被一个循环的 thenable 链中的对象解决，而 <font style="color:#1890ff;background-color: #e2dcdc;padding:3px">[[Resolve]](promise, y)</font> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励开发者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为拒绝原因来拒绝 promise [<a href="#3.6">3.6</a>]</h5><h2 id="3-注释"><a href="#3-注释" class="headerlink" title=" 3. 注释 "></a><strong> 3. 注释 </strong></h2><hr>
<h6 id="emsp-emsp-3-1-这里的平台代码指的是引擎、环境以及-promise-的实施代码。实践中要确保-onFulfilled-和-onRejected-方法异步执行，且应该在-then-方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于-promise-的实施代码本身就是平台代码，故代码自身在处理在处理程序时可能已经包含一个任务调度队列。"><a href="#emsp-emsp-3-1-这里的平台代码指的是引擎、环境以及-promise-的实施代码。实践中要确保-onFulfilled-和-onRejected-方法异步执行，且应该在-then-方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于-promise-的实施代码本身就是平台代码，故代码自身在处理在处理程序时可能已经包含一个任务调度队列。" class="headerlink" title="&emsp;&emsp; [3.1] 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码，故代码自身在处理在处理程序时可能已经包含一个任务调度队列。"></a>&emsp;&emsp; <a name="3.1">[3.1]</a> 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用“宏任务（macro-task）”机制或者“微任务（micro-task）”机制来实现。由于 promise 的实施代码本身就是平台代码，故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</h6><h6 id="emsp-emsp-3-2-也就是说在严格模式（strict）中，函数-this-的值为-undefined-；在非严格模式中其为全局对象。"><a href="#emsp-emsp-3-2-也就是说在严格模式（strict）中，函数-this-的值为-undefined-；在非严格模式中其为全局对象。" class="headerlink" title="&emsp;&emsp; [3.2] 也就是说在严格模式（strict）中，函数 this 的值为 undefined ；在非严格模式中其为全局对象。"></a>&emsp;&emsp; <a name="3.2">[3.2]</a> 也就是说在严格模式（strict）中，函数 this 的值为 undefined ；在非严格模式中其为全局对象。</h6><h6 id="emsp-emsp-3-3-如果代码实现满足了规范的所有要求，可以允许-promise2-promise1-。同时要文档说明在何种条件下允许-promise2-promise1。"><a href="#emsp-emsp-3-3-如果代码实现满足了规范的所有要求，可以允许-promise2-promise1-。同时要文档说明在何种条件下允许-promise2-promise1。" class="headerlink" title="&emsp;&emsp; [3.3] 如果代码实现满足了规范的所有要求，可以允许 promise2 === promise1 。同时要文档说明在何种条件下允许 promise2 === promise1。"></a>&emsp;&emsp; <a name="3.3">[3.3]</a> 如果代码实现满足了规范的所有要求，可以允许 promise2 === promise1 。同时要文档说明在何种条件下允许 promise2 === promise1。</h6><h6 id="emsp-emsp-3-4-一般来说，只有当-x-符合当前实现，我们才认为它是真正的-promise-。这一规则允许那些特例实现接受符合已知要求的-Promises-状态。"><a href="#emsp-emsp-3-4-一般来说，只有当-x-符合当前实现，我们才认为它是真正的-promise-。这一规则允许那些特例实现接受符合已知要求的-Promises-状态。" class="headerlink" title="&emsp;&emsp; [3.4] 一般来说，只有当 x 符合当前实现，我们才认为它是真正的 promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。"></a>&emsp;&emsp; <a name="3.4">[3.4]</a> 一般来说，只有当 x 符合当前实现，我们才认为它是真正的 promise 。这一规则允许那些特例实现接受符合已知要求的 Promises 状态。</h6><h6 id="emsp-emsp-3-5-这个过程首先存储一个指向-x-then-的引用，然后测试并调用该引用，以避免多次访问-x-then-属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用中被改变。"><a href="#emsp-emsp-3-5-这个过程首先存储一个指向-x-then-的引用，然后测试并调用该引用，以避免多次访问-x-then-属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用中被改变。" class="headerlink" title="&emsp;&emsp; [3.5] 这个过程首先存储一个指向 x.then 的引用，然后测试并调用该引用，以避免多次访问 x.then 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用中被改变。"></a>&emsp;&emsp; <a name="3.5">[3.5]</a> 这个过程首先存储一个指向 x.then 的引用，然后测试并调用该引用，以避免多次访问 x.then 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用中被改变。</h6><h6 id="emsp-emsp-3-6-实现不应该对-thenable-链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致-TypeError-异常；如果一条无限长的链上-thenable-均不相同，那么递归下去永远是正确的行为。"><a href="#emsp-emsp-3-6-实现不应该对-thenable-链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致-TypeError-异常；如果一条无限长的链上-thenable-均不相同，那么递归下去永远是正确的行为。" class="headerlink" title="&emsp;&emsp; [3.6] 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。"></a>&emsp;&emsp; <a name="3.6">[3.6]</a> 实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。</h6>
        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <!-- <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div> -->
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

